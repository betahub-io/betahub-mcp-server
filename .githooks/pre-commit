#!/bin/bash

# Git pre-commit hook to detect potential PAT tokens
# Prevents committing files that contain strings matching PAT token patterns

set -e

# Color codes for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Token patterns to check for
# PAT format: pat-{64 hex characters}
# Project token format: tkn-{64 hex characters}
PAT_PATTERN='(pat|tkn)-[a-fA-F0-9]{64}'

# Additional patterns for other common token formats
# Generic 64-char hex strings that might be tokens
GENERIC_TOKEN_PATTERN='[a-fA-F0-9]{64}'

# Files to check (staged files only)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    exit 0
fi

# Flag to track if tokens were found
TOKENS_FOUND=0
SUSPICIOUS_FILES=""

echo "üîç Checking staged files for potential tokens..."

for FILE in $STAGED_FILES; do
    # Skip binary files
    if file --mime-type "$FILE" | grep -q "text/"; then
        # Get the staged content (not the working directory version)
        STAGED_CONTENT=$(git show ":$FILE" 2>/dev/null || true)

        if [ -z "$STAGED_CONTENT" ]; then
            continue
        fi

        # Check for PAT/TKN tokens
        if echo "$STAGED_CONTENT" | grep -qE "$PAT_PATTERN"; then
            echo -e "${RED}‚ùå BLOCKED: Found PAT/TKN token pattern in: $FILE${NC}"
            TOKENS_FOUND=1
            SUSPICIOUS_FILES="$SUSPICIOUS_FILES\n  - $FILE (PAT/TKN token)"

            # Show the line containing the token (masked)
            LINES=$(echo "$STAGED_CONTENT" | grep -nE "$PAT_PATTERN" | head -3)
            while IFS= read -r line; do
                if [ -n "$line" ]; then
                    LINE_NUM=$(echo "$line" | cut -d: -f1)
                    # Mask the token in output
                    MASKED_LINE=$(echo "$line" | sed -E 's/((pat|tkn)-)[a-fA-F0-9]{64}/\1**REDACTED**/g')
                    echo -e "  ${YELLOW}Line $LINE_NUM: ${MASKED_LINE:0:100}...${NC}"
                fi
            done <<< "$LINES"
        fi

        # Check for generic 64-char hex strings in specific files
        # Only check certain file types where tokens are likely
        case "$FILE" in
            *.env|*.env.*|*.json|*.yml|*.yaml|*.js|*.ts|*.jsx|*.tsx|*.py|*.sh|*.bash)
                # Look for standalone 64-char hex strings
                if echo "$STAGED_CONTENT" | grep -qE "^[^a-fA-F0-9]*[a-fA-F0-9]{64}[^a-fA-F0-9]*$|['\"][a-fA-F0-9]{64}['\"]"; then
                    echo -e "${YELLOW}‚ö†Ô∏è  WARNING: Found potential 64-char token in: $FILE${NC}"
                    echo -e "${YELLOW}   Please verify this is not a secret token.${NC}"

                    # Show context (masked)
                    LINES=$(echo "$STAGED_CONTENT" | grep -nE "[a-fA-F0-9]{64}" | head -2)
                    while IFS= read -r line; do
                        if [ -n "$line" ]; then
                            LINE_NUM=$(echo "$line" | cut -d: -f1)
                            MASKED_LINE=$(echo "$line" | sed -E 's/[a-fA-F0-9]{64}/**POTENTIAL-TOKEN**/g')
                            echo -e "  ${YELLOW}Line $LINE_NUM: ${MASKED_LINE:0:100}...${NC}"
                        fi
                    done <<< "$LINES"
                fi
                ;;
        esac
    fi
done

# Check result and provide guidance
if [ $TOKENS_FOUND -eq 1 ]; then
    echo ""
    echo -e "${RED}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${RED}üö´ COMMIT BLOCKED: Potential secrets detected!${NC}"
    echo -e "${RED}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo ""
    echo -e "Found potential tokens in the following files:${SUSPICIOUS_FILES}"
    echo ""
    echo "To fix this issue:"
    echo "1. Remove the token from the file"
    echo "2. Use environment variables instead (e.g., process.env.BETAHUB_TOKEN)"
    echo "3. Add sensitive files to .gitignore"
    echo ""
    echo "If this is a false positive (e.g., a test token or documentation):"
    echo "  - You can bypass this check with: git commit --no-verify"
    echo "  - But please double-check that no real tokens are being committed!"
    echo ""
    exit 1
else
    echo -e "${GREEN}‚úÖ No tokens detected in staged files${NC}"
fi

exit 0